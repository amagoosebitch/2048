class Field {
	field int startX, startY, score;
	field boolean failed;
	field Array поле;
    field Random rnd;

	constructor Field new(int startXArg, int startYArg) {
		var int i, j;
        var Array tempRow;
		let startX = startXArg;
		let startY = startYArg;
		let score = 0;
		let failed = false;
		let i = 0;
        let поле = Array.new(4);
		while (i < 4) {
			let поле[i] = Array.new(4);
            while (j < 4) {
                let tempRow = поле[i];
                let tempRow[j] = 0;
                let j = j + 1;
            }
            let j = 0;
			let i = i + 1;
		}

        let rnd = Random.new(69, 13, 37, 160);
        
		return this;
	}

	method void dispose() {
        do Memory.deAlloc(поле[0]);
        do Memory.deAlloc(поле[1]);
        do Memory.deAlloc(поле[2]);
        do Memory.deAlloc(поле[3]);
        do поле.dispose();
		do Memory.deAlloc(this);
		return;
	}

	method void display() {
		var int x, y, memAddress;
		var String string;
        var Array tempRow;

		do Screen.setColor(true); 
		do Screen.drawRectangle(0, 24, 511, 255); 
		do Screen.drawRectangle(0, 0, 511, 8); 
		do Screen.drawRectangle(100, 0, 511, 255);
        
		do Screen.setColor(false);
		do Screen.drawRectangle(0, 8, 100, 24);

		do Output.moveCursor(1, 0);
		let string = "SCORE: ";
		do Output.printString(string);
		do string.dispose();
		do Output.printInt(score);

		do Screen.setColor(false);

		do Screen.drawRectangle(startX - 4, startY - 4, startX + 68, startY + 68);

		do Screen.setColor(true);
		do Screen.drawRectangle(startX, startY, startX + 64, startY + 64);

		let x = 0;
		let y = 0;
		while (y < 4) {
            do Screen.setColor(false);
            do Screen.drawRectangle(startX + (16*x) + 1, startY + (16*y) + 1, 
            	startX + (16*x) + 15, startY + (16*y) + 15);
            

			let memAddress = 16384 + 32 + (startX/16) + (startY*32) + (y*512) + x;
            
            let tempRow = поле[y];
            do draw(memAddress, tempRow[x]);
			let x = x + 1;
			if (x > 3) {
				let y = y + 1;
				let x = 0;
			}
		}
		
        do Memory.deAlloc(tempRow);
		return;
	}

    method void draw(int memAddress, int value) {
        if (value = 2) {
            do draw2(memAddress);
        } if (value = 4) {
            do draw4(memAddress);
        } if (value = 8) {
            do draw8(memAddress);
        } if (value = 16) {
            do draw16(memAddress);
        } if (value = 32) {
            do draw32(memAddress);
        } if (value = 64) {
            do draw64(memAddress);
        } if (value = 128) {
            do draw128(memAddress);
        } if (value = 256) {
            do draw256(memAddress);
        } if (value = 512) {
            do draw512(memAddress);
        } if (value = 1024) {
            do draw1024(memAddress);
        } if (value = 2048) {
            do draw2048(memAddress);
        }
        return;
    }

    method void draw2(int memAddress) {
        // рисуем 2
        do Memory.poke(memAddress+0, 1);
        do Memory.poke(memAddress+32, 1);
        do Memory.poke(memAddress+64, 2017);
        do Memory.poke(memAddress+96, 3121);
        do Memory.poke(memAddress+128, 2065);
        do Memory.poke(memAddress+160, 3073);
        do Memory.poke(memAddress+192, 1537);
        do Memory.poke(memAddress+224, 769);
        do Memory.poke(memAddress+256, 385);
        do Memory.poke(memAddress+288, 193);
        do Memory.poke(memAddress+320, 97);
        do Memory.poke(memAddress+352, 49);
        do Memory.poke(memAddress+384, 4081);
        do Memory.poke(memAddress+416, 1);
        do Memory.poke(memAddress+448, 1);
        do Memory.poke(memAddress+480, -1);
        return;
    }

    method void draw4(int memAddress) {
        // рисуем 4
        do Memory.poke(memAddress+0, 1);
        do Memory.poke(memAddress+32, 1);
        do Memory.poke(memAddress+64, 1057);
        do Memory.poke(memAddress+96, 1057);
        do Memory.poke(memAddress+128, 1057);
        do Memory.poke(memAddress+160, 1057);
        do Memory.poke(memAddress+192, 1057);
        do Memory.poke(memAddress+224, 2017);
        do Memory.poke(memAddress+256, 1025);
        do Memory.poke(memAddress+288, 1025);
        do Memory.poke(memAddress+320, 1025);
        do Memory.poke(memAddress+352, 1025);
        do Memory.poke(memAddress+384, 1025);
        do Memory.poke(memAddress+416, 1);
        do Memory.poke(memAddress+448, 1);
        do Memory.poke(memAddress+480, -1);
        return;
    }

    method void draw8(int memAddress) {
        // рисуем 8
        do Memory.poke(memAddress+0, 1);
        do Memory.poke(memAddress+32, 1);
        do Memory.poke(memAddress+64, 1985);
        do Memory.poke(memAddress+96, 3169);
        do Memory.poke(memAddress+128, 2081);
        do Memory.poke(memAddress+160, 2081);
        do Memory.poke(memAddress+192, 3169);
        do Memory.poke(memAddress+224, 1985);
        do Memory.poke(memAddress+256, 3169);
        do Memory.poke(memAddress+288, 2081);
        do Memory.poke(memAddress+320, 2081);
        do Memory.poke(memAddress+352, 3169);
        do Memory.poke(memAddress+384, 1985);
        do Memory.poke(memAddress+416, 1);
        do Memory.poke(memAddress+448, 1);
        do Memory.poke(memAddress+480, -1);
        return;
    }

    method void draw16(int memAddress) {
        // рисуем 16
        do Memory.poke(memAddress+0, 1);
        do Memory.poke(memAddress+32, 1);
        do Memory.poke(memAddress+64, 3857);
        do Memory.poke(memAddress+96, 6545);
        do Memory.poke(memAddress+128, 4241);
        do Memory.poke(memAddress+160, 145);
        do Memory.poke(memAddress+192, 145);
        do Memory.poke(memAddress+224, 3985);
        do Memory.poke(memAddress+256, 6545);
        do Memory.poke(memAddress+288, 4241);
        do Memory.poke(memAddress+320, 4241);
        do Memory.poke(memAddress+352, 6545);
        do Memory.poke(memAddress+384, 3857);
        do Memory.poke(memAddress+416, 1);
        do Memory.poke(memAddress+448, 1);
        do Memory.poke(memAddress+480, -1);
        return;
    }

    method void draw32(int memAddress) {
        // рисуем 32
        do Memory.poke(memAddress+0, 1);
        do Memory.poke(memAddress+32, 1);
        do Memory.poke(memAddress+64, 15481);
        do Memory.poke(memAddress+96, 26317);
        do Memory.poke(memAddress+128, 17029);
        do Memory.poke(memAddress+160, 16513);
        do Memory.poke(memAddress+192, 24769);
        do Memory.poke(memAddress+224, 12409);
        do Memory.poke(memAddress+256, 6337);
        do Memory.poke(memAddress+288, 2177);
        do Memory.poke(memAddress+320, 3205);
        do Memory.poke(memAddress+352, 1741);
        do Memory.poke(memAddress+384, 32377);
        do Memory.poke(memAddress+416, 1);
        do Memory.poke(memAddress+448, 1);
        do Memory.poke(memAddress+480, -1);
        return;
    }

    method void draw64(int memAddress) {
        // рисуем 64
        do Memory.poke(memAddress+0, 1);
        do Memory.poke(memAddress+32, 1);
        do Memory.poke(memAddress+64, 17017);
        do Memory.poke(memAddress+96, 17101);
        do Memory.poke(memAddress+128, 17029);
        do Memory.poke(memAddress+160, 16901);
        do Memory.poke(memAddress+192, 16901);
        do Memory.poke(memAddress+224, 32381);
        do Memory.poke(memAddress+256, 16589);
        do Memory.poke(memAddress+288, 16517);
        do Memory.poke(memAddress+320, 16517);
        do Memory.poke(memAddress+352, 16589);
        do Memory.poke(memAddress+384, 16505);
        do Memory.poke(memAddress+416, 1);
        do Memory.poke(memAddress+448, 1);
        do Memory.poke(memAddress+480, -1);
        return;
    }

    method void draw128(int memAddress) {
        // рисуем 128
        do Memory.poke(memAddress+0, 1);
        do Memory.poke(memAddress+32, 1);
        do Memory.poke(memAddress+64, 14565);
        do Memory.poke(memAddress+96, 28085);
        do Memory.poke(memAddress+128, 17685);
        do Memory.poke(memAddress+160, 17669);
        do Memory.poke(memAddress+192, 28037);
        do Memory.poke(memAddress+224, 14469);
        do Memory.poke(memAddress+256, 27845);
        do Memory.poke(memAddress+288, 17509);
        do Memory.poke(memAddress+320, 17461);
        do Memory.poke(memAddress+352, 27669);
        do Memory.poke(memAddress+384, 14837);
        do Memory.poke(memAddress+416, 1);
        do Memory.poke(memAddress+448, 1);
        do Memory.poke(memAddress+480, -1);
        return;
    }

    method void draw256(int memAddress) {
        // рисуем 256
        do Memory.poke(memAddress+0, 1);
        do Memory.poke(memAddress+32, 1);
        do Memory.poke(memAddress+64, 31677);
        do Memory.poke(memAddress+96, 18597);
        do Memory.poke(memAddress+128, 18597);
        do Memory.poke(memAddress+160, 2209);
        do Memory.poke(memAddress+192, 2225);
        do Memory.poke(memAddress+224, 2193);
        do Memory.poke(memAddress+256, 31641);
        do Memory.poke(memAddress+288, 18953);
        do Memory.poke(memAddress+320, 18957);
        do Memory.poke(memAddress+352, 18949);
        do Memory.poke(memAddress+384, 31677);
        do Memory.poke(memAddress+416, 1);
        do Memory.poke(memAddress+448, 1);
        do Memory.poke(memAddress+480, -1);
        return;
    }

    method void draw512(int memAddress) {
        // рисуем 512
        do Memory.poke(memAddress+0, 1);
        do Memory.poke(memAddress+32, 1);
        do Memory.poke(memAddress+64, 14717);
        do Memory.poke(memAddress+96, 27909);
        do Memory.poke(memAddress+128, 17669);
        do Memory.poke(memAddress+160, 16645);
        do Memory.poke(memAddress+192, 24837);
        do Memory.poke(memAddress+224, 12605);
        do Memory.poke(memAddress+256, 4449);
        do Memory.poke(memAddress+288, 6465);
        do Memory.poke(memAddress+320, 3393);
        do Memory.poke(memAddress+352, 1377);
        do Memory.poke(memAddress+384, 32061);
        do Memory.poke(memAddress+416, 1);
        do Memory.poke(memAddress+448, 1);
        do Memory.poke(memAddress+480, -1);
        return;
    }

    method void draw1024(int memAddress) {
        // рисуем 1024
        do Memory.poke(memAddress+0, 1);
        do Memory.poke(memAddress+32, 1);
        do Memory.poke(memAddress+64, 1);
        do Memory.poke(memAddress+96, 1);
        do Memory.poke(memAddress+128, 21029);
        do Memory.poke(memAddress+160, 22389);
        do Memory.poke(memAddress+192, 21845);
        do Memory.poke(memAddress+224, 29781);
        do Memory.poke(memAddress+256, 18005);
        do Memory.poke(memAddress+288, 17269);
        do Memory.poke(memAddress+320, 18213);
        do Memory.poke(memAddress+352, 1);
        do Memory.poke(memAddress+384, 1);
        do Memory.poke(memAddress+416, 1);
        do Memory.poke(memAddress+448, 1);
        do Memory.poke(memAddress+480, -1);
        return;
    }

    method void draw2048(int memAddress) {
        // рисуем 2048
        do Memory.poke(memAddress+0, 1);
        do Memory.poke(memAddress+32, 1);
        do Memory.poke(memAddress+64, 1);
        do Memory.poke(memAddress+96, 1);
        do Memory.poke(memAddress+128, 1);
        do Memory.poke(memAddress+160, 30445);
        do Memory.poke(memAddress+192, 22185);
        do Memory.poke(memAddress+224, 30381);
        do Memory.poke(memAddress+256, 21669);
        do Memory.poke(memAddress+288, 29933);
        do Memory.poke(memAddress+320, 1);
        do Memory.poke(memAddress+352, 1);
        do Memory.poke(memAddress+384, 1);
        do Memory.poke(memAddress+416, 1);
        do Memory.poke(memAddress+448, 1);
        do Memory.poke(memAddress+480, -1);
        return;
    }

	method void setFailed() {
		let failed = true;
		return;
	}

	method boolean getFail() {
		return failed;
	}

    method void slideRowLeft(Array row) {
        var int temp, i, j;
        var boolean exit;
		// i should be 1. it represents the index of the access for row. (doesn't
		// include 0 because there's nothing to slide into)
		let i = 1;
		// only iterate if i is in the indices of row. 
		while (i < 4) {
			let exit = false;
			// check if the number is non-zero.
			if (~(row[i] = 0)) {
				// if it is, then you can move it until it's all the way to the
				// left or about to hit another number.
				let j = i;
				while (~exit) {
					let j = j - 1;
					// case 1: it hits another number. 
					if (~(row[j] = 0)) {
						let exit = true;
						let j = j + 1;
						let temp = row[i];
						let row[i] = 0;
						let row[j] = temp;
					}
					// case 2: it hits all the way to the left.
					if ((j = 0) & ~exit) {
						let exit = true;
						let temp = row[i];
						let row[i] = 0;
						let row[j] = temp;
					}
				}
			}
			let i = i + 1;
		}
        return;
    }

	method void slideLeft() {
		var Array row;
        var int i, j, temp;

		let i = 0;
        while (i < 4) {
            let row = поле[i];
            do slideRowLeft(row);
            let i = i + 1;
        }
		return;
	}

	method void slideRight() {
        var Array rowCopy, row;
		var int i, j;

		let i = 0;
        let j = 0;
        while (i < 4) {
            let rowCopy = Array.new(4);
            let row = поле[i];
            while (j < 4) {
                let rowCopy[j] = row[3-j];
                let j = j + 1;
            }
            let j = 0;
            do slideRowLeft(rowCopy);
            while (j < 4) {
                let row[j] = rowCopy[3-j];
                let j = j + 1;
            }
            let j = 0;
            let поле[i] = row;
            let i = i + 1;
            do Memory.deAlloc(rowCopy);
        }
        return;
	}

    method void mergeRowLeft(Array row) {
        var int i;
        let i = 0;

        while (i < 3) { // i = 3 represents row[3] and row[4], not existent
			if (row[i] = row[i+1]) {
				let row[i] = row[i]*2;
				let score = score + row[i];
				let row[i + 1] = 0;
			}
            let i = i + 1;
        }
        return;
    }

	method void mergeLeft() {
		var Array row;
        var int i;
		
		let i = 0; 
		while (i < 4) { 
            let row = поле[i];
            do mergeRowLeft(row);
            let i = i + 1;
		}
		return; 
	}

	method void mergeRight() {
		var int i, j;
        var Array row, rowCopy;
		
		let i = 0;
        let j = 0;
		while (i < 4) { 
            let rowCopy = Array.new(4);
            let row = поле[i];
            while (j < 4) {
                let rowCopy[j] = row[3-j];
                let j = j + 1;
            }
            let j = 0;
            do mergeRowLeft(rowCopy);
            while (j < 4) {
                let row[j] = rowCopy[3-j];
                let j = j + 1;
            }
            let j = 0;
            do Memory.deAlloc(rowCopy);
            let i = i + 1;
		}
		return; 
	}

	/**
	  * Description: Replicates the left command on the real 2048 app. 
	  */
	method void moveLeft(boolean test) {
		var Field original;
		let original = copy();
		do slideLeft();
		do mergeLeft();
		do slideLeft();
		if (~(compareState(original))) {
			do spawnRandomNum();
		}
		do original.dispose(); 
        if (~test) {
            do checkFailed();
        }
		return; 
	}

	method void moveRight(boolean test) {
		var Field original;
		let original = copy();
		do slideRight();
		do mergeRight();
		do slideRight();
		
		if (~(compareState(original))) {
			do spawnRandomNum();
		}
		do original.dispose();
        if (~test) {
            do checkFailed();
        }
		return;
	}

	method boolean compareState(Field other) {
		var Array stateOther, row1Other, row2Other, row3Other, row4Other, row1, row2, row3, row4;
		let stateOther = other.getState();
		let row1Other = stateOther[0];
		let row2Other = stateOther[1];
		let row3Other = stateOther[2];
		let row4Other = stateOther[3];
        let row1 = поле[0];
		let row2 = поле[1];
		let row3 = поле[2];
		let row4 = поле[3];
		return (row1[0] = row1Other[0]) &
		       (row1[1] = row1Other[1]) &
		       (row1[2] = row1Other[2]) &
		       (row1[3] = row1Other[3]) &
		       (row2[0] = row2Other[0]) &
		       (row2[1] = row2Other[1]) &
		       (row2[2] = row2Other[2]) &
		       (row2[3] = row2Other[3]) &
		       (row3[0] = row3Other[0]) &
		       (row3[1] = row3Other[1]) &
		       (row3[2] = row3Other[2]) &
		       (row3[3] = row3Other[3]) &
		       (row4[0] = row4Other[0]) &
		       (row4[1] = row4Other[1]) &
		       (row4[2] = row4Other[2]) &
		       (row4[3] = row4Other[3]);
	}

	method Array getState() {
		var Array result;
		let result = Array.new(4);
		let result[0] = поле[0];
		let result[1] = поле[1];
		let result[2] = поле[2];
		let result[3] = поле[3];
		return result;
	}

	method void slideUp() {
		var int i, j, temp;
		var boolean exit;
        var Array col, row;
        let i = 0;
        let j = 0;
        
        while (i < 4) {
            let col = Array.new(4);
            while (j < 4) {
                let row = поле[j];
                let col[j] = row[3-i];
                let j = j + 1;
            }
            let j = 0;
            do slideRowLeft(col);
            while (j < 4) {
                let row = поле[j];
                let row[3-i] = col[j];
                let j = j + 1;
            }
            let j = 0;
            let i = i + 1;
            do Memory.deAlloc(col);
        }
        return;
	}

	method void mergeUp() {
        var Array col, row;
		var int i, j;
		
		let i = 0; // this represents the pair of row1[0] and row1[1]
		while (i < 4) {
            let col = Array.new(4);
            while (j < 4) {
                let row = поле[j];
                let col[j] = row[3-i];
                let j = j + 1;
            }
            let j = 0;
            do mergeRowLeft(col);
            while (j < 4) {
                let row = поле[j];
                let row[3-i] = col[j];
                let j = j + 1;
            }
            let j = 0;
            let i = i + 1;
            do Memory.deAlloc(col);
        }
		return; 
	}

	method void moveUp(boolean test) {
		var Field original;
		let original = copy();
		do slideUp();
		do mergeUp();
		do slideUp();
		// only spawn if the field state changed
		if (~(compareState(original))) {
			do spawnRandomNum();
		}
		do original.dispose(); // saves space
        if (~test) {
            do checkFailed();
        }
		return; // part of the language
	}

	/**
	  * Description: Slides each number to the bottom as much as they can.
	  */
	method void slideDown() {
		var int i, j;
        var Array col, row;
        let i = 0;
        let j = 0;
        
        while (i < 4) {
            let col = Array.new(4);
            while (j < 4) {
                let row = поле[3-j];
                let col[j] = row[i];
                let j = j + 1;
            }
            let j = 0;
            do slideRowLeft(col);
            while (j < 4) {
                let row = поле[3-j];
                let row[i] = col[j];
                let j = j + 1;
            }
            let j = 0;
            let i = i + 1;
            do Memory.deAlloc(col);
        }
        return;
	}

	method void mergeDown() {
		var int i, j;
        var Array col, row;
        let i = 0;
        let j = 0;
        
        while (i < 4) {
            let col = Array.new(4);
            while (j < 4) {
                let row = поле[3-j];
                let col[j] = row[i];
                let j = j + 1;
            }
            let j = 0;
            do mergeRowLeft(col);
            while (j < 4) {
                let row = поле[3-j];
                let row[i] = col[j];
                let j = j + 1;
            }
            let j = 0;
            let i = i + 1;
            do Memory.deAlloc(col);
        }
		return; // part of the language		
	}

	method void moveDown(boolean test) {
		var Field original;
		let original = copy();
		do slideDown();
		do mergeDown();
		do slideDown();
		if (~(compareState(original))) {
			do spawnRandomNum();
		}
		do original.dispose();
        if (~test) {
            do checkFailed();
        }
		return;
	}

	method void spawnRandomNum() {
		var int location, rowNum, colNum, iterations, num;
        var Array row;
		let iterations = 0;

		let num = 2;
		if (rnd.random() > 143) {
			let num = 4;
		}
		while (iterations < 160) {
			let iterations = iterations + 1;
			let location = rnd.random() / 10;
			let colNum = MathExtension.modulus(location, 4);
            let rowNum = location/4;

            if ((rowNum > -1) & (rowNum < 4)) {
                let row = поле[rowNum];
                if ((colNum > -1) & (colNum < 4) & (row[colNum] = 0)) {
                    let row[colNum] = num;
                    return;
                }
            } 
		}
		return;
	}

	method void configureState(Array prevField) {
        var int i, j;
        var Array row, rowCopy;
        let i = 0;
        let j = 0;

        while (i < 4) {
            let row = поле[i];
            let rowCopy = prevField[i];
            while (j < 4) {
                let row[j] = rowCopy[j];
                let j = j + 1;
            }
            let j = 0;
            let i = i + 1;
        }

		return;
	}

	method void setScore(int scoreArg) {
		let score = scoreArg;
		return;
	}

	method Field copy() {
		var Field copy;
        var Array rowCopy, row, newField;
        var int i, j;
        let i = 0;
        let j = 0;

        let newField = Array.new(4);
        while (i < 4) {
            let rowCopy = Array.new(4);
            let row = поле[i];
            while (j < 4) {
                let rowCopy[j] = row[j];
                let j = j + 1;
            }
            let j = 0;
            let newField[i] = rowCopy;
            let i = i + 1;
        }
		let copy = Field.new(startX, startY);
		do copy.configureState(newField);
		do copy.setScore(score);
		return copy;
	}

	method void checkFailed() {
		var Field failTest;
		let failTest = copy();
		do failTest.moveLeft(true);
		if (~(compareState(failTest))) {
			do failTest.dispose();
			return;
		}

		do failTest.moveUp(true);
		if (~(compareState(failTest))) {
			do failTest.dispose();
			return;
		}

		do failTest.moveRight(true);
		if (~(compareState(failTest))) {
			do failTest.dispose();
			return;
		}

		do failTest.moveDown(true);
		if (~(compareState(failTest))) {
			do failTest.dispose();
			return;
		}

		do failTest.dispose();
		do setFailed();
		return;
	}
}